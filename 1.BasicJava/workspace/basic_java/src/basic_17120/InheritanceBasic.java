package basic_17120;

import java.util.ArrayList;
import java.util.List;

public class InheritanceBasic {
	public static void main(String[] args) {
		/*
		 	1. 상속 (~은 ~이다)
		 		-기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
		 		-적은양의 코드로 새로운 클래스를 작성 할 수 있다.
		 		-새로 작성하고자 하는 클래스의 뒤에 생속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 써주기만 하면 된다.
		 		
		 		class Child extends Parent{
		 			
		 		
		 		}
		 		
		 		-상속해주는 클래스를 '조상클래스', 상속받는 클래스를 '자손클래스'라고 한다.
		 			조상클래스 : 부모클래스, 상위클래스, 기반클래스
		 			자손클래스 : 자식클래스, 하위클래스, 파생클래스
	 			-멤버만 상속한다.
	 			-자손클래스의 멤버개수는 조상클래스와 같거나 보다 많다.
		 		
	 		2. 포함(~은 ~을 가지고 있다.)
	 			-상속 이외에 클래스를 재사용 하는 또다른 방법.
	 			-한 클래스의 멤버변수로 다른 클래스를 선언하는 방법이다.
	 			
	 			
			3. toString()
				-인스턴스의 문자열을 반환할 목적으로 정의
				-참조변수를 출력하면 참조변수가 가르키고 있는 인스턴스의 toString()을 호출한다.
				-System.out.println(c.toString*();
	 			
	 		4. 단일상속
	 			-자바에서는 단일상속 (2개이상은 불가능)만 가능하다.
	 			 class TVCR extends TV{} 		: o
	 			 class TVCR extends TV,VCE{}	: x
	 			-TV와 VCR에 동일한 메서드가 있다면 어떤것을 상속받을지 알 수 없기 떄문.
	 			-VCR의 메서드 명을 바꾼다면 그동안 VCR의 메서드를 사용하던 부분들을 전부 수정해주어야 한다.
	 			-클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있도록 해 준다.
	 		
	 		5. Object
	 			-모든 클래스의 조상
	 			-다른 클래스로부터 상속받지 않는 모든 클래스는 Object클래스를 상속받는다.
	 			 class TV (extends Object)
 			 	-toString(), equals()와 같은 메서드들을 따로 정의하지 않고 사용할 수 있는것은 Object클래스에 정의되어
 			 	 있기 때문이다.
		 	6. overriding
		 		-부모클래스로부터 상속받은 메서드의내용을 변경하는 것.
		 		-오버라이드가 성립하기 위한 조건 : 선언부의 일치
		 			:자손클래스에서 오버라이딩 하는 메서드는 부모클래스의 메서드와 이름이 같아야 한다.
		 		     매개변수의 타입과 개수가 같아야 한다
		 			 리턴타입이 같아야 한다
		 			:조상클래스의 메서드를 자손 클래스에서 오버라이딩 할 때
		 			 접근제어자를 조상클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
		 			 예외처리는 조상클래스의 메서드보다 많이 선언할 수 없다.
		 			 인스턴스 메서드->클래스메서드 혹은 그 반대로 변경 할 수 없다.
		 			 
		 	7. super
		 		-조상클래스의 멤버와 자손클래스의 멤버를 서로 구별 할 때 사용
		 		-조상클래스의 멤버와 자손클래스의 멤버를 구별하는데 사용된다는 점을
		 		 제외하고는 this와 근본적으로 같다.
		 	 	-클래스메서드에서 사용 할 수 없고 인스턴스 메서드에서만 사용 할 수 있다. 
		 			 
		 	8. super() - 조상클래스의 생성자 호출
		 		-this()와 마찬가지로 super()역시 생성자 호출이다.
		 		-this()는 같은 클래스의 다른 생성자 호출
		 		 super()는 조상클래스의 생성자를 호출
		 		-생성자의 첫줄에는 조상클래스의 생성자를 호출한다.
		 		 자손클래스의 멤버가 조상클래스의 멤버를 사용 할 수 있으므로
		 		 조상의 멤버들이 먼저 초기화 되어야 한다.
		 		 
		 	9. Access Modifier
		 		-클래스, 또는 변수 또는 메서드 선언부에 사용된다.
		 		-접근제어자와 그 외 제어자
		 		-접근제어자 : private default protected public
		 		-그외제어자 : static final abstract 
		 		-일반적으로 접근제어자를 가장 왼쪽에 써 준다.
		 		-static(클래스의, 공통적인)
		 			: 멤버변수 메서드 초기화블럭에 사용된다
		 			: static 변수
		 				모든 인스턴스에서 공통적으로 사용
		 				인스턴스를 생성하지 않고도 사용 가능
		 				클래스가 메모리에 로드될 때 생성된다
	 				: static 메서드
		 				인스턴스를 생성하지 않고도 사용 가능
		 				클래스메서드 안에서는 인스턴스 멤버를 사용 할 수 없다.
		 				
 				-final (마지막의, 변경 할 수 없는)
 					: 변수에 사용 할 경우 상수가 된다.
 					: 메서드에 사용 할 경우 -> 오버라이딩이 불가능하다.
 					: 클래스에 사용할 경우 -> 상속이 되지 않는다.(부모클래스가 될 수 없다.)
 					
 				-abstract(추상의, 미완성의)
 					: 추상 메서드를 가지고 있는 클래스는 추상 클래스가 된다.
 					: 추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말한다.
 					: 메서드와 클래스에 사용 가능.
 					: 메서드에 사용시 구현부가 없어도 된다.
 					
			10. 접근제어자
				-private : 같은 클래스 내에서만 접근 가능하다.
				-default : 같은 패키지 내에서만 접근 가능하다.
				-protected : 같은 패키지 + 다른 패키지의 자손클래스
				-public : 접근 제한이 없다.
				
				-클래스 : public, default
				-메소드,변수 : 모두 사용 가능함
				
			11.캡슐화
				-접근제어자를 사용하는 이유
					:외부로부터 데이터를 보호하기 위해
					:외부에서 불필요한, 네부적으로만 사용되는 부분을 감추기 위해
					
			12.생성자의 접근제어자
				- 인스턴스의 생성을 제한하기 위해 사용
				- 생성자의 접근제어자를 private으로 지정
					:외부에서 생성자에 접근 할 수 없으므로 인스턴스를 생성 할 수 없다.
					:다른 클래스의 조상이 될 수 없다.
					:상속 할 수 없는 클래스임으로 final을 추가하여 상속 할 수 없는 클래스임을 알리는 것이 좋다.
			
			13.다형성(polymorphism)
				-여러가지 형태를 가질 수 있는 능력
				-한 타입의 참조변수로 여러 타입의 객체를 참조 할 수 있다.
				-조상타입의 참조변수로 자손타입의 인스턴스를 참조 할 수 있다.
					(ex List as = new ArrayList(); <이런거) (부모가 왼, 자손이 오른)
			
			14. 참조변수의 형변환
				-서로 상속관계에 있는 클래스에서만 형변환이 가능하다.
				-자손타입 -> 조상타입 (up-casting) : 캐스트 연산자 생략 가능
				 조상타입 -> 자손타입 (down-casting) : 캐스트 연산자 생략은 불가능하다.
			
			15. instanceof 연산자
				-참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다.
				-연산결과가 true 라면 참조변수가 검사 한 타입으로 형변환이 가능하다.
				fc instanceof Car
					: fc가 Car의 인스턴스인가? (return bool)
				-클래스 메서드는 클래스 변수처럼 참조변수의 타입에 영향을 받는다.
				-참조변수의 타입에 영향을 받지 않는것은 인스턴스메서드 뿐이다.
			
			16. 매개변수의 다형성
				- 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.
				
			17.여러 객체 배열 Vector
				- 조상타입의 참조변수로 자손타입의 인스턴스를 참조 할 수 있다. (다형성)
					Product p1 = new Tv();
					Product p2 = new Notebook();
					Product p3 = new Styler();
					
					Product[] p = new Product[3];
					p[0] = p1;
					p[1] = p2;
					p[2] = p3;
					
					Vector<Product> vc = new Vector<Product>();
				
				-Vector
					:배열을 사용 할 경우 전체 크기를 한 번 정하면 확장 할 수 없기때문에
					 이것을 해결하기 위해 사용.
				
					-메서드
						Vector() 				: 10개의 객체를 저장 할 수 있는 Vector인스턴스를 생성한다.
							   					  10개가 넘어가면 자동으로 크기가 증가.
					    add() 					: 객체를 추가할 때 사용. (Create)
					    remove() 				: 객체를 제거한다. (Delete)
					    isEmpty()				: 비어있는지 체크 (boolean타입)
					    size()	 				: 저장된 객체의 개수를 반환한다.
					    <Object> get(int index) : index번째 객체를 반환한다.
			18.추상클래스(abstract class)
				-미완성 된 클래스 : 미완성 된 메서드를 포함하고 있다는 의미
					abstract class 클래스 명{
					}
				-추상메서드
					:메서드는 선언부와 구현부로 구성되어있다.
				 	 선언부만 작성되어있고 구현부는 작성하지 않은 메서드를 추상메서드라고 한다.
			 	-추상클래스로부터 상속받는 자손클래스는 추상클래스가 되어야 한다.
			 	 추상클래스가 되기 싫으면 추상메서드를 오버라이드 하면 된다.
			 	 
		 	 19.인터페이스
		 	 	-일종의 추상클래스이지만 추상메서드와 상수만을 멤버로 가진다.
		 	 	-인터페이스의 작성
		 	 		interface 인터페이스명 {
			 	 		public static final 변수타입 상수명 = 값;
			 	 		public abstract 반환타입 메서드명(매개변수);
		 	 		}
	 	 		-모든 멤버변수는 public static final이어야한다. 생략 할수 있다.
	 	 		-모든 메서드는 public abstract이어야 한다. 생략 할 수 있다.
	 	 		
	 	 		-인터페이스 상속
	 	 			: 인터페이스는 인터페이스로부터만 상속받을 수 있다.
		 	 		: 클래스와는 달리 다중상속이 가능하다.
		 	 		: 인터페이스는 클래스와 달리 Object클래스와 같은 최고 조상이 없다.
	 	 		-인터페이스의 구현
	 	 			: 자체로는 인스턴스를 생성 할 수 없다.
	 	 			: 자신이 정의된 추상메서드의 몸통을 만들어주는 클래스가 있어야 한다.
	 	 			: 클래스의 확장(extends) 구현 (implements)
	 	 			: 인터페이스의 일부 메서드만 구현하였다면 그 클래스는 추상클래스로 선언되어야 한다.
	 	 			: ~able 필요한 메서드를 강조하기 위해
	 	 			 IMember => IMemberImpl
	 	 			 
 	 			-인터페이스의 다형성
 	 				:인터페이스 타입의 참조변수로 구현한 클래스의 인스턴스를 참조 할 수 있다.
 	 					IMember im - new ImemberImpl();
 	 					
 	 			-인터페이스의 장점
 	 				:개발시간을 단축 할 수 있다.
 	 				:표준화가 가능하다.
 	 				:서로 관계가 없는 클래스들에게 관계를 맺어준다.
 	 			
		 */
	}
}











































